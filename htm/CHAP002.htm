<html><head><title>[Alnuth] 2 Methods for number fields</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP001.htm">Previous</a>] [<a href ="CHAP003.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>2 Methods for number fields</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP002.htm#SECT001">Creation of number fields</a>
<li> <A HREF="CHAP002.htm#SECT002">Methods for number fields</a>
<li> <A HREF="CHAP002.htm#SECT003">Presentations of multiplicative subgroups</a>
<li> <A HREF="CHAP002.htm#SECT004">Methods to compute with subgroups of the unit group</a>
<li> <A HREF="CHAP002.htm#SECT005">Factorisation of polynomials over a number field</a>
<li> <A HREF="CHAP002.htm#SECT006">Examples</a>
</ol><p>
<p>
An algebraic number field is a finite-dimensional extension of the
rational numbers <b>Q</b>. Such a number field has a primitive element 
and it can be defined by the minimal polynomial of  this primitive
element. Another important way to define an algebraic number field
is by a set of rational matrices which generate a number field.
<p>
<p>
<h2><a name="SECT001">2.1 Creation of number fields</a></h2>
<p><p>
We provide functions to create number fields defined by rational 
matrices or by rational polynomials.
<p>
<a name = "SSEC001.1"></a>
<li><code>FieldByMatricesNC( </code><var>matrices</var><code> )</code>
<a name = "SSEC001.1"></a>
<li><code>FieldByMatrices( </code><var>matrices</var><code> )</code>
<p>
Creates a field generated by the rational matrices <var>matrices</var>. In 
the faster NC version, the function assumes that the input generates 
a field and there are no checks on this performed. 
<p>
<a name = "SSEC001.2"></a>
<li><code>FieldByMatrixBasisNC( </code><var>matrices</var><code> )</code>
<a name = "SSEC001.2"></a>
<li><code>FieldByMatrixBasis( </code><var>matrices</var><code> )</code>
<p>
Creates a field with basis <var>matrices</var>. The list <var>matrices</var> must consist 
of rational matrices which form a basis for a number field. In the faster
NC version, the function assumes that the input is a matrix basis for a
field and no checks are performed.
<p>
<a name = "SSEC001.3"></a>
<li><code>FieldByPolynomialNC( </code><var>polynomial</var><code> )</code>
<a name = "SSEC001.3"></a>
<li><code>FieldByPolynomial( </code><var>polynomial</var><code> )</code>
<p>
Creates a field defined by <var>polynomial</var>. The polynomial <var>polynomial</var>
must be an irreducible rational polynomial. In the faster NC version,
no checks on the input are performed.
<p>
<p>
<h2><a name="SECT002">2.2 Methods for number fields</a></h2>
<p><p>
We outline a number of functions for number fields.
<p>
<a name = "SSEC002.1"></a>
<li><code>PrimitiveElement( </code><var>F</var><code> )</code>
<a name = "SSEC002.1"></a>
<li><code>DefiningPolynomial( </code><var>F</var><code> )</code>
<p>
Computes a primitive element and a defining polynomial for the given number
field. The defining polynomial is the minimal polynomial of the primitive
element. Since <var>F</var> contains various primitive elements, 
<code>PrimitiveElement</code> tries to find a primitive element which has a
minimal polynomial with small coefficients. Via the global variable
<var>PRIM_TEST</var> the user can decide how many primitive elements will be
compared. The default value is 20.
<p>
<a name = "SSEC002.2"></a>
<li><code>IsPrimitiveElementOfNumberField( </code><var>F</var><code>, </code><var>a</var><code> )</code>
<p>
Checks if the given element generates the field.
<p>
<a name = "SSEC002.3"></a>
<li><code>DegreeOverPrimeField( </code><var>F</var><code> )</code>
<p>
Returns the degree of <var>F</var> over the rationals. 
<p>
<a name = "SSEC002.4"></a>
<li><code>EquationOrderBasis( </code><var>F</var><code> )</code>
<a name = "SSEC002.4"></a>
<li><code>MaximalOrderBasis( </code><var>F</var><code> )</code>
<a name = "SSEC002.4"></a>
<li><code>IsIntegerOfNumberField( </code><var>F</var><code>, </code><var>k</var><code> )</code>
<p>
These functions return bases for the equation order or the maximal order
of the number field <var>F</var>. Also, they allow to check if a given element is
an integer in the given number field.
<p>
<a name = "SSEC002.5"></a>
<li><code>UnitGroup( </code><var>F</var><code> )</code>
<p>
determines the unit group of <var>F</var>.
<p>
Recall that the unit group of <var>F</var> is a finitely generated abelian
group. The function <code>IsomorphismPcpGroup</code> from the <font face="Gill Sans,Helvetica,Arial">Polycyclic</font>
<a href="biblio.htm#Polycyclic"><cite>Polycyclic</cite></a> package gives an isomorphism to a pcp group which
can be used for various computations with the unit group. 
<p>
<a name = "SSEC002.6"></a>
<li><code>IsUnitOfNumberField( </code><var>F</var><code>, </code><var>k</var><code> )</code>
<p>
checks whether the element <var>k</var> is a unit in <var>F</var>. 
<p>
<a name = "SSEC002.7"></a>
<li><code>ExponentsOfUnits( </code><var>F</var><code>, </code><var>elms</var><code> )</code>
<p>
This function determines the exponent vectors of the elements in <var>elms</var>
with respect to the generators of the unit group of <var>F</var>. If the unit
group of <var>F</var> is not known, then the function computes this unit group also.
<p>
<a name = "SSEC002.8"></a>
<li><code>IsCyclotomicField( </code><var>F</var><code> )</code>
<p>
Check whether <var>F</var> is cyclotomic.
<p>
<a name = "SSEC002.9"></a>
<li><code>NormCosetsOfNumberField( </code><var>F</var><code>, </code><var>norm</var><code> )</code>
<p>
Returns a description for the set of all elements of norm <var>norm</var> in <var>F</var>. 
These elements can be written as a finite union of cosets of the unit
group of <var>F</var>. The function returns coset representatives for these cosets.
<p>
<p>
<h2><a name="SECT003">2.3 Presentations of multiplicative subgroups</a></h2>
<p><p>
Suppose that a finite number of
invertible elements
of a number field are given. Then these elements generate a finitely
generated abelian group. However, it is a non-trivial task to provide
a presentation for this abelian group. The most useful representation
for such groups is as pcp group.
<p>
<a name = "SSEC003.1"></a>
<li><code>PcpPresentationOfMultiplicativeSubgroup( </code><var>F</var><code>, </code><var>elms</var><code> )</code>
<a name = "SSEC003.1"></a>
<li><code>IsomorphismPcpGroup( </code><var>F</var><code>, </code><var>elms</var><code> )</code>
<p>
Determine a pcp presentation for the multiplicative group of
<i>F</i> \{0} generated by
<var>elms</var> and an isomorphism on this presentation. 
Note, that the method <code>IsomorphismPcpGroup</code> is defined in the
<font face="Gill Sans,Helvetica,Arial">Polycyclic</font> package <a href="biblio.htm#Polycyclic"><cite>Polycyclic</cite></a>. We refer to the manual of this
package for further background. 
<p>
In the determination of the Pcp-presentation of a multiplicative
subgroup generated by <var>elms</var> the relations between the elements in
<var>elms</var> play an important role.
Let <i>elms</i>={<i>e</i><sub>1</sub>,...,<i>e</i><sub><i>l</i></sub>} be a finite subset of a field <var>F</var>.
The relation lattice for <var>elms</var> is 
<br clear="all" /><table border="0" width="100%"><tr><td><table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center"> <i>rl</i>(<i>elms</i>):={(<i>h</i><sub>1</sub>,...,<i>h</i><sub><i>l</i></sub>)  &#8712; <b>Z</b><sup><i>l</i></sup> &#124; <i>e</i><sub>1</sub><sup><i>h</i><sub>1</sub></sup> &#8230;<i>e</i><sub><i>l</i></sub><sup><i>h</i><sub><i>l</i></sub></sup> = 1} &#183;</td></tr></table></td></tr></table>
<p>
<a name = "SSEC003.2"></a>
<li><code>RelationLattice( </code><var>F</var><code>, </code><var>elms</var><code> )</code>
<p>
Determines a generating set 
for the relation lattice of the field elements <var>elms</var>.
<p>
<p>
<h2><a name="SECT004">2.4 Methods to compute with subgroups of the unit group</a></h2>
<p><p>
<a name = "SSEC004.1"></a>
<li><code>RelationLatticeOfUnits( </code><var>F</var><code>, </code><var>elms</var><code> )</code>
<p>
Determines a basis for the relation lattice of the units <var>elms</var> in 
triangularized form. Note that this method is more efficient than 
the method <code>RelationLattice</code>.
<p>
<a name = "SSEC004.2"></a>
<li><code>IntersectionOfUnitSubgroups( </code><var>F</var><code>, </code><var>gen1</var><code>, </code><var>gen2</var><code> )</code>
<p>
The lists <var>gen1</var> and <var>gen2</var> are supposed to generate two subgroups 
<i>U</i><sub>1</sub> and <i>U</i><sub>2</sub> of the unit group of <var>F</var>. This function determines 
the intersection of <i>U</i><sub>1</sub> with <i>U</i><sub>2</sub>. The result is returned as a 
list of vectors generating the lattice { <i>e</i>  &#8712; <b>Z</b><sup><i>n</i></sup>  | <i>g</i><sub>1</sub><sup><i>e</i><sub>1</sub></sup> &#8230;<i>g</i><sub><i>n</i></sub><sup><i>e</i><sub><i>n</i></sub></sup>  &#8712; <i>U</i><sub>2</sub> } for <var>gen1</var> = [<i>g</i><sub>1</sub>, &#8230;, <i>g</i><sub><i>n</i></sub>].
<p>
For efficiency reasons this function does not check the input and it 
may return wrong results if the input generators do not fulfil the 
requirements.
<p>
<p>
<h2><a name="SECT005">2.5 Factorisation of polynomials over a number field</a></h2>
<p><p>
<a name = "SSEC005.1"></a>
<li><code>FactorsPolynomialAlgExt( </code><var>F</var><code>, </code><var>pol</var><code> )</code>
<p>
embeds the rational polynomial <var>pol</var> into the polynomial ring over the
number field <var>F</var>, which has to be constructed by <code>FieldByPolynomial</code>
or <code>AlgebraicExtension</code>, and returns the factorization of the embedded
polynomial.  By default <var>a</var> denotes the primitive element of the field
one can obtain from <code>PrimitiveElement(</code><var>F</var><code>)</code>, that is, a root of the
defining polynomial of <var>F</var>. 
<p>
<a name = "SSEC005.2"></a>
<li><code>FactorsPolynomialPari( </code><var>pol</var><code> )</code>
<p>
takes a polynomial <var>pol</var> defined over an algebraic extension of the
Rationals and factors it using PARI/GP.
<p>
<pre>
gap&gt; x := Indeterminate( Rationals, "x" );;
gap&gt; pol := 2*x^7+2*x^5+8*x^4+8*x^2;
2*x^7+2*x^5+8*x^4+8*x^2
gap&gt; L := FieldByPolynomial( x^3-4 );
&lt;algebraic extension over the Rationals of degree 3&gt;
gap&gt; y := Indeterminate( L, "y" );;
gap&gt; FactorsPolynomialAlgExt( L, pol );
[ !2*y, y, y+(a), y^2+!1, y^2+((-1*a))*y+(a^2) ]
gap&gt; FactorsPolynomialPari( last[5] );
[ y^2+((-1*a))*y+(a^2) ]
gap&gt;
</pre>
<p>
<p>
<h2><a name="SECT006">2.6 Examples</a></h2>
<p><p>
<a name = "SSEC006.1"></a>
<li><code>ExampleMatField( </code><var>l</var><code> )</code>
<p>
This function returns some examples of fields generated by matrices. 
There are 9 such example fields provided and they can be obtained by
assigning the input <var>l</var> to an integer between 1 and 9. Some of the
properties of the examples are summarized in the following table.
<p>
<pre>
                    degree over Q  number of generators  dim. of generators
ExampleMatField(1)              4                     4                   4
ExampleMatField(2)              4                     4                   4
ExampleMatField(3)              4                     4                   4
ExampleMatField(4)              4                    13                   4
ExampleMatField(5)              4                    13                   4
ExampleMatField(6)              4                     7                   4
ExampleMatField(7)              4                    18                   4
ExampleMatField(8)              4                    13                   4
ExampleMatField(9)              4                     7                   4
</pre>
<p>
<p>
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP001.htm">Previous</a>] [<a href ="CHAP003.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<address>Alnuth manual<br>April 2022
</address></body></html>